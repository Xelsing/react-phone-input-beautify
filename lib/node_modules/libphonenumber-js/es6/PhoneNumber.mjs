"use client";
import l from "./metadata.mjs";
import c from "./isPossible.mjs";
import y from "./isValid.mjs";
import h from "./helpers/getNumberType.mjs";
import m from "./helpers/getPossibleCountriesForNumber.mjs";
import g from "./format.mjs";
function a(n, t) {
  var e = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), e.push.apply(e, r);
  }
  return e;
}
function o(n) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a(Object(e), !0).forEach(function(r) {
      b(n, r, e[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(e)) : a(Object(e)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(e, r));
    });
  }
  return n;
}
function b(n, t, e) {
  return t in n ? Object.defineProperty(n, t, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : n[t] = e, n;
}
function p(n, t) {
  if (!(n instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function u(n, t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r);
  }
}
function d(n, t, e) {
  return t && u(n.prototype, t), e && u(n, e), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
var j = /* @__PURE__ */ function() {
  function n(t, e, r) {
    if (p(this, n), !t)
      throw new TypeError("`country` or `countryCallingCode` not passed");
    if (!e)
      throw new TypeError("`nationalNumber` not passed");
    if (!r)
      throw new TypeError("`metadata` not passed");
    var i = C(t, r), s = i.country, f = i.countryCallingCode;
    this.country = s, this.countryCallingCode = f, this.nationalNumber = e, this.number = "+" + this.countryCallingCode + this.nationalNumber, this.getMetadata = function() {
      return r;
    };
  }
  return d(n, [{
    key: "setExt",
    value: function(e) {
      this.ext = e;
    }
  }, {
    key: "getPossibleCountries",
    value: function() {
      return this.country ? [this.country] : m(this.countryCallingCode, this.nationalNumber, this.getMetadata());
    }
  }, {
    key: "isPossible",
    value: function() {
      return c(this, {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "isValid",
    value: function() {
      return y(this, {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "isNonGeographic",
    value: function() {
      var e = new l(this.getMetadata());
      return e.isNonGeographicCallingCode(this.countryCallingCode);
    }
  }, {
    key: "isEqual",
    value: function(e) {
      return this.number === e.number && this.ext === e.ext;
    }
    // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
    // but later it was found out that it doesn't include the possible `TOO_SHORT` result
    // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,
    // so eventually I simply commented out this method from the `PhoneNumber` class
    // and just left the `validatePhoneNumberLength()` function, even though that one would require
    // and additional step to also validate the actual country / calling code of the phone number.
    // validateLength() {
    // 	const metadata = new Metadata(this.getMetadata())
    // 	metadata.selectNumberingPlan(this.countryCallingCode)
    // 	const result = checkNumberLength(this.nationalNumber, metadata)
    // 	if (result !== 'IS_POSSIBLE') {
    // 		return result
    // 	}
    // }
  }, {
    key: "getType",
    value: function() {
      return h(this, {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "format",
    value: function(e, r) {
      return g(this, e, r ? o(o({}, r), {}, {
        v2: !0
      }) : {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "formatNational",
    value: function(e) {
      return this.format("NATIONAL", e);
    }
  }, {
    key: "formatInternational",
    value: function(e) {
      return this.format("INTERNATIONAL", e);
    }
  }, {
    key: "getURI",
    value: function(e) {
      return this.format("RFC3966", e);
    }
  }]), n;
}(), v = function(t) {
  return /^[A-Z]{2}$/.test(t);
};
function C(n, t) {
  var e, r, i = new l(t);
  return v(n) ? (e = n, i.selectNumberingPlan(e), r = i.countryCallingCode()) : r = n, {
    country: e,
    countryCallingCode: r
  };
}
export {
  j as default
};
