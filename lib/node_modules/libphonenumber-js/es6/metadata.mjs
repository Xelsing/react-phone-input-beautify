"use client";
import f from "./tools/semver-compare.mjs";
import s from "./helpers/isObject.mjs";
function l(n) {
  "@babel/helpers - typeof";
  return l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, l(n);
}
function r(n, t) {
  if (!(n instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function h(n, t) {
  for (var e = 0; e < t.length; e++) {
    var a = t[e];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(n, a.key, a);
  }
}
function o(n, t, e) {
  return t && h(n.prototype, t), e && h(n, e), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
var v = "1.2.0", P = "1.7.35", g = " ext. ", d = /^\d+$/, C = /* @__PURE__ */ function() {
  function n(t) {
    r(this, n), k(t), this.metadata = t, y.call(this, t);
  }
  return o(n, [{
    key: "getCountries",
    value: function() {
      return Object.keys(this.metadata.countries).filter(function(e) {
        return e !== "001";
      });
    }
  }, {
    key: "getCountryMetadata",
    value: function(e) {
      return this.metadata.countries[e];
    }
  }, {
    key: "nonGeographic",
    value: function() {
      if (!(this.v1 || this.v2 || this.v3))
        return this.metadata.nonGeographic || this.metadata.nonGeographical;
    }
  }, {
    key: "hasCountry",
    value: function(e) {
      return this.getCountryMetadata(e) !== void 0;
    }
  }, {
    key: "hasCallingCode",
    value: function(e) {
      if (this.getCountryCodesForCallingCode(e))
        return !0;
      if (this.nonGeographic()) {
        if (this.nonGeographic()[e])
          return !0;
      } else {
        var a = this.countryCallingCodes()[e];
        if (a && a.length === 1 && a[0] === "001")
          return !0;
      }
    }
  }, {
    key: "isNonGeographicCallingCode",
    value: function(e) {
      return this.nonGeographic() ? !!this.nonGeographic()[e] : !this.getCountryCodesForCallingCode(e);
    }
    // Deprecated.
  }, {
    key: "country",
    value: function(e) {
      return this.selectNumberingPlan(e);
    }
  }, {
    key: "selectNumberingPlan",
    value: function(e, a) {
      if (e && d.test(e) && (a = e, e = null), e && e !== "001") {
        if (!this.hasCountry(e))
          throw new Error("Unknown country: ".concat(e));
        this.numberingPlan = new c(this.getCountryMetadata(e), this);
      } else if (a) {
        if (!this.hasCallingCode(a))
          throw new Error("Unknown calling code: ".concat(a));
        this.numberingPlan = new c(this.getNumberingPlanMetadata(a), this);
      } else
        this.numberingPlan = void 0;
      return this;
    }
  }, {
    key: "getCountryCodesForCallingCode",
    value: function(e) {
      var a = this.countryCallingCodes()[e];
      if (a)
        return a.length === 1 && a[0].length === 3 ? void 0 : a;
    }
  }, {
    key: "getCountryCodeForCallingCode",
    value: function(e) {
      var a = this.getCountryCodesForCallingCode(e);
      if (a)
        return a[0];
    }
  }, {
    key: "getNumberingPlanMetadata",
    value: function(e) {
      var a = this.getCountryCodeForCallingCode(e);
      if (a)
        return this.getCountryMetadata(a);
      if (this.nonGeographic()) {
        var i = this.nonGeographic()[e];
        if (i)
          return i;
      } else {
        var u = this.countryCallingCodes()[e];
        if (u && u.length === 1 && u[0] === "001")
          return this.metadata.countries["001"];
      }
    }
    // Deprecated.
  }, {
    key: "countryCallingCode",
    value: function() {
      return this.numberingPlan.callingCode();
    }
    // Deprecated.
  }, {
    key: "IDDPrefix",
    value: function() {
      return this.numberingPlan.IDDPrefix();
    }
    // Deprecated.
  }, {
    key: "defaultIDDPrefix",
    value: function() {
      return this.numberingPlan.defaultIDDPrefix();
    }
    // Deprecated.
  }, {
    key: "nationalNumberPattern",
    value: function() {
      return this.numberingPlan.nationalNumberPattern();
    }
    // Deprecated.
  }, {
    key: "possibleLengths",
    value: function() {
      return this.numberingPlan.possibleLengths();
    }
    // Deprecated.
  }, {
    key: "formats",
    value: function() {
      return this.numberingPlan.formats();
    }
    // Deprecated.
  }, {
    key: "nationalPrefixForParsing",
    value: function() {
      return this.numberingPlan.nationalPrefixForParsing();
    }
    // Deprecated.
  }, {
    key: "nationalPrefixTransformRule",
    value: function() {
      return this.numberingPlan.nationalPrefixTransformRule();
    }
    // Deprecated.
  }, {
    key: "leadingDigits",
    value: function() {
      return this.numberingPlan.leadingDigits();
    }
    // Deprecated.
  }, {
    key: "hasTypes",
    value: function() {
      return this.numberingPlan.hasTypes();
    }
    // Deprecated.
  }, {
    key: "type",
    value: function(e) {
      return this.numberingPlan.type(e);
    }
    // Deprecated.
  }, {
    key: "ext",
    value: function() {
      return this.numberingPlan.ext();
    }
  }, {
    key: "countryCallingCodes",
    value: function() {
      return this.v1 ? this.metadata.country_phone_code_to_countries : this.metadata.country_calling_codes;
    }
    // Deprecated.
  }, {
    key: "chooseCountryByCountryCallingCode",
    value: function(e) {
      return this.selectNumberingPlan(e);
    }
  }, {
    key: "hasSelectedNumberingPlan",
    value: function() {
      return this.numberingPlan !== void 0;
    }
  }]), n;
}(), c = /* @__PURE__ */ function() {
  function n(t, e) {
    r(this, n), this.globalMetadataObject = e, this.metadata = t, y.call(this, e.metadata);
  }
  return o(n, [{
    key: "callingCode",
    value: function() {
      return this.metadata[0];
    }
    // Formatting information for regions which share
    // a country calling code is contained by only one region
    // for performance reasons. For example, for NANPA region
    // ("North American Numbering Plan Administration",
    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
    // it will be contained in the metadata for `US`.
  }, {
    key: "getDefaultCountryMetadataForRegion",
    value: function() {
      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
    }
    // Is always present.
  }, {
    key: "IDDPrefix",
    value: function() {
      if (!(this.v1 || this.v2))
        return this.metadata[1];
    }
    // Is only present when a country supports multiple IDD prefixes.
  }, {
    key: "defaultIDDPrefix",
    value: function() {
      if (!(this.v1 || this.v2))
        return this.metadata[12];
    }
  }, {
    key: "nationalNumberPattern",
    value: function() {
      return this.v1 || this.v2 ? this.metadata[1] : this.metadata[2];
    }
    // "possible length" data is always present in Google's metadata.
  }, {
    key: "possibleLengths",
    value: function() {
      if (!this.v1)
        return this.metadata[this.v2 ? 2 : 3];
    }
  }, {
    key: "_getFormats",
    value: function(e) {
      return e[this.v1 ? 2 : this.v2 ? 3 : 4];
    }
    // For countries of the same region (e.g. NANPA)
    // formats are all stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "formats",
    value: function() {
      var e = this, a = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
      return a.map(function(i) {
        return new p(i, e);
      });
    }
  }, {
    key: "nationalPrefix",
    value: function() {
      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
    }
  }, {
    key: "_getNationalPrefixFormattingRule",
    value: function(e) {
      return e[this.v1 ? 4 : this.v2 ? 5 : 6];
    }
    // For countries of the same region (e.g. NANPA)
    // national prefix formatting rule is stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "nationalPrefixFormattingRule",
    value: function() {
      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "_nationalPrefixForParsing",
    value: function() {
      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
    }
  }, {
    key: "nationalPrefixForParsing",
    value: function() {
      return this._nationalPrefixForParsing() || this.nationalPrefix();
    }
  }, {
    key: "nationalPrefixTransformRule",
    value: function() {
      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
    }
  }, {
    key: "_getNationalPrefixIsOptionalWhenFormatting",
    value: function() {
      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
    }
    // For countries of the same region (e.g. NANPA)
    // "national prefix is optional when formatting" flag is
    // stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function() {
      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "leadingDigits",
    value: function() {
      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
    }
  }, {
    key: "types",
    value: function() {
      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
    }
  }, {
    key: "hasTypes",
    value: function() {
      return this.types() && this.types().length === 0 ? !1 : !!this.types();
    }
  }, {
    key: "type",
    value: function(e) {
      if (this.hasTypes() && m(this.types(), e))
        return new F(m(this.types(), e), this);
    }
  }, {
    key: "ext",
    value: function() {
      return this.v1 || this.v2 ? g : this.metadata[13] || g;
    }
  }]), n;
}(), p = /* @__PURE__ */ function() {
  function n(t, e) {
    r(this, n), this._format = t, this.metadata = e;
  }
  return o(n, [{
    key: "pattern",
    value: function() {
      return this._format[0];
    }
  }, {
    key: "format",
    value: function() {
      return this._format[1];
    }
  }, {
    key: "leadingDigitsPatterns",
    value: function() {
      return this._format[2] || [];
    }
  }, {
    key: "nationalPrefixFormattingRule",
    value: function() {
      return this._format[3] || this.metadata.nationalPrefixFormattingRule();
    }
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function() {
      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
  }, {
    key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
    value: function() {
      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
    // Checks whether national prefix formatting rule contains national prefix.
  }, {
    key: "usesNationalPrefix",
    value: function() {
      return !!(this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
      !b.test(this.nationalPrefixFormattingRule()));
    }
  }, {
    key: "internationalFormat",
    value: function() {
      return this._format[5] || this.format();
    }
  }]), n;
}(), b = /^\(?\$1\)?$/, F = /* @__PURE__ */ function() {
  function n(t, e) {
    r(this, n), this.type = t, this.metadata = e;
  }
  return o(n, [{
    key: "pattern",
    value: function() {
      return this.metadata.v1 ? this.type : this.type[0];
    }
  }, {
    key: "possibleLengths",
    value: function() {
      if (!this.metadata.v1)
        return this.type[1] || this.metadata.possibleLengths();
    }
  }]), n;
}();
function m(n, t) {
  switch (t) {
    case "FIXED_LINE":
      return n[0];
    case "MOBILE":
      return n[1];
    case "TOLL_FREE":
      return n[2];
    case "PREMIUM_RATE":
      return n[3];
    case "PERSONAL_NUMBER":
      return n[4];
    case "VOICEMAIL":
      return n[5];
    case "UAN":
      return n[6];
    case "PAGER":
      return n[7];
    case "VOIP":
      return n[8];
    case "SHARED_COST":
      return n[9];
  }
}
function k(n) {
  if (!n)
    throw new Error("[libphonenumber-js] `metadata` argument not passed. Check your arguments.");
  if (!s(n) || !s(n.countries))
    throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(s(n) ? "an object of shape: { " + Object.keys(n).join(", ") + " }" : "a " + x(n) + ": " + n, "."));
}
var x = function(t) {
  return l(t);
};
function I(n, t) {
  if (t = new C(t), t.hasCountry(n))
    return t.country(n).countryCallingCode();
  throw new Error("Unknown country: ".concat(n));
}
function D(n, t) {
  return t.countries.hasOwnProperty(n);
}
function y(n) {
  var t = n.version;
  typeof t == "number" ? (this.v1 = t === 1, this.v2 = t === 2, this.v3 = t === 3, this.v4 = t === 4) : t ? f(t, v) === -1 ? this.v2 = !0 : f(t, P) === -1 ? this.v3 = !0 : this.v4 = !0 : this.v1 = !0;
}
export {
  C as default,
  I as getCountryCallingCode,
  D as isSupportedCountry,
  k as validateMetadata
};
