"use client";
import b from "./helpers/extractCountryCallingCode.mjs";
import C from "./helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.mjs";
import s from "./helpers/extractNationalNumberFromPossiblyIncompleteNumber.mjs";
import y from "./helpers/stripIddPrefix.mjs";
import x from "./helpers/parseDigits.mjs";
import { VALID_PUNCTUATION as c, VALID_DIGITS as d, PLUS_CHARS as v } from "./constants.mjs";
function h(n, e) {
  return I(n) || A(n, e) || S(n, e) || P();
}
function P() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function S(n, e) {
  if (n) {
    if (typeof n == "string")
      return N(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return N(n, e);
  }
}
function N(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, i = new Array(e); t < e; t++)
    i[t] = n[t];
  return i;
}
function A(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var i = [], a = !0, r = !1, u, l;
    try {
      for (t = t.call(n); !(a = (u = t.next()).done) && (i.push(u.value), !(e && i.length === e)); a = !0)
        ;
    } catch (o) {
      r = !0, l = o;
    } finally {
      try {
        !a && t.return != null && t.return();
      } finally {
        if (r)
          throw l;
      }
    }
    return i;
  }
}
function I(n) {
  if (Array.isArray(n))
    return n;
}
function _(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function m(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i);
  }
}
function p(n, e, t) {
  return e && m(n.prototype, e), t && m(n, t), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
var E = "[" + c + d + "]+", D = new RegExp("^" + E + "$", "i"), T = "(?:[" + v + "][" + c + d + "]*|[" + c + d + "]+)", R = new RegExp("[^" + c + d + "]+.*$"), k = /[^\d\[\]]/, B = /* @__PURE__ */ function() {
  function n(e) {
    var t = e.defaultCountry, i = e.defaultCallingCode, a = e.metadata, r = e.onNationalSignificantNumberChange;
    _(this, n), this.defaultCountry = t, this.defaultCallingCode = i, this.metadata = a, this.onNationalSignificantNumberChange = r;
  }
  return p(n, [{
    key: "input",
    value: function(t, i) {
      var a = M(t), r = h(a, 2), u = r[0], l = r[1], o = x(u), f;
      return l && (i.digits || (i.startInternationalNumber(), o || (f = !0))), o && this.inputDigits(o, i), {
        digits: o,
        justLeadingPlus: f
      };
    }
    /**
     * Inputs "next" phone number digits.
     * @param  {string} digits
     * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means "don't format the national phone number at this stage".
     */
  }, {
    key: "inputDigits",
    value: function(t, i) {
      var a = i.digits, r = a.length < 3 && a.length + t.length >= 3;
      if (i.appendDigits(t), r && this.extractIddPrefix(i), this.isWaitingForCountryCallingCode(i)) {
        if (!this.extractCountryCallingCode(i))
          return;
      } else
        i.appendNationalSignificantNumberDigits(t);
      i.international || this.hasExtractedNationalSignificantNumber || this.extractNationalSignificantNumber(i.getNationalDigits(), function(u) {
        return i.update(u);
      });
    }
  }, {
    key: "isWaitingForCountryCallingCode",
    value: function(t) {
      var i = t.international, a = t.callingCode;
      return i && !a;
    }
    // Extracts a country calling code from a number
    // being entered in internatonal format.
  }, {
    key: "extractCountryCallingCode",
    value: function(t) {
      var i = b("+" + t.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), a = i.countryCallingCode, r = i.number;
      if (a)
        return t.setCallingCode(a), t.update({
          nationalSignificantNumber: r
        }), !0;
    }
  }, {
    key: "reset",
    value: function(t) {
      if (t) {
        this.hasSelectedNumberingPlan = !0;
        var i = t._nationalPrefixForParsing();
        this.couldPossiblyExtractAnotherNationalSignificantNumber = i && k.test(i);
      } else
        this.hasSelectedNumberingPlan = void 0, this.couldPossiblyExtractAnotherNationalSignificantNumber = void 0;
    }
    /**
     * Extracts a national (significant) number from user input.
     * Google's library is different in that it only applies `national_prefix_for_parsing`
     * and doesn't apply `national_prefix_transform_rule` after that.
     * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539
     * @return {boolean} [extracted]
     */
  }, {
    key: "extractNationalSignificantNumber",
    value: function(t, i) {
      if (this.hasSelectedNumberingPlan) {
        var a = s(t, this.metadata), r = a.nationalPrefix, u = a.nationalNumber, l = a.carrierCode;
        if (u !== t)
          return this.onExtractedNationalNumber(r, l, u, t, i), !0;
      }
    }
    /**
     * In Google's code this function is called "attempt to extract longer NDD".
     * "Some national prefixes are a substring of others", they say.
     * @return {boolean} [result] â€” Returns `true` if extracting a national prefix produced different results from what they were.
     */
  }, {
    key: "extractAnotherNationalSignificantNumber",
    value: function(t, i, a) {
      if (!this.hasExtractedNationalSignificantNumber)
        return this.extractNationalSignificantNumber(t, a);
      if (this.couldPossiblyExtractAnotherNationalSignificantNumber) {
        var r = s(t, this.metadata), u = r.nationalPrefix, l = r.nationalNumber, o = r.carrierCode;
        if (l !== i)
          return this.onExtractedNationalNumber(u, o, l, t, a), !0;
      }
    }
  }, {
    key: "onExtractedNationalNumber",
    value: function(t, i, a, r, u) {
      var l, o, f = r.lastIndexOf(a);
      if (f >= 0 && f === r.length - a.length) {
        o = !0;
        var g = r.slice(0, f);
        g !== t && (l = g);
      }
      u({
        nationalPrefix: t,
        carrierCode: i,
        nationalSignificantNumber: a,
        nationalSignificantNumberMatchesInput: o,
        complexPrefixBeforeNationalSignificantNumber: l
      }), this.hasExtractedNationalSignificantNumber = !0, this.onNationalSignificantNumberChange();
    }
  }, {
    key: "reExtractNationalSignificantNumber",
    value: function(t) {
      if (this.extractAnotherNationalSignificantNumber(t.getNationalDigits(), t.nationalSignificantNumber, function(i) {
        return t.update(i);
      }))
        return !0;
      if (this.extractIddPrefix(t))
        return this.extractCallingCodeAndNationalSignificantNumber(t), !0;
      if (this.fixMissingPlus(t))
        return this.extractCallingCodeAndNationalSignificantNumber(t), !0;
    }
  }, {
    key: "extractIddPrefix",
    value: function(t) {
      var i = t.international, a = t.IDDPrefix, r = t.digits;
      if (t.nationalSignificantNumber, !(i || a)) {
        var u = y(r, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);
        if (u !== void 0 && u !== r)
          return t.update({
            IDDPrefix: r.slice(0, r.length - u.length)
          }), this.startInternationalNumber(t, {
            country: void 0,
            callingCode: void 0
          }), !0;
      }
    }
  }, {
    key: "fixMissingPlus",
    value: function(t) {
      if (!t.international) {
        var i = C(t.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), a = i.countryCallingCode;
        if (i.number, a)
          return t.update({
            missingPlus: !0
          }), this.startInternationalNumber(t, {
            country: t.country,
            callingCode: a
          }), !0;
      }
    }
  }, {
    key: "startInternationalNumber",
    value: function(t, i) {
      var a = i.country, r = i.callingCode;
      t.startInternationalNumber(a, r), t.nationalSignificantNumber && (t.resetNationalSignificantNumber(), this.onNationalSignificantNumberChange(), this.hasExtractedNationalSignificantNumber = void 0);
    }
  }, {
    key: "extractCallingCodeAndNationalSignificantNumber",
    value: function(t) {
      this.extractCountryCallingCode(t) && this.extractNationalSignificantNumber(t.getNationalDigits(), function(i) {
        return t.update(i);
      });
    }
  }]), n;
}();
function F(n) {
  var e = n.search(T);
  if (!(e < 0)) {
    n = n.slice(e);
    var t;
    return n[0] === "+" && (t = !0, n = n.slice(1)), n = n.replace(R, ""), t && (n = "+" + n), n;
  }
}
function O(n) {
  var e = F(n) || "";
  return e[0] === "+" ? [e.slice(1), !0] : [e];
}
function M(n) {
  var e = O(n), t = h(e, 2), i = t[0], a = t[1];
  return D.test(i) || (i = ""), [i, a];
}
export {
  B as default,
  M as extractFormattedDigitsAndPlus
};
