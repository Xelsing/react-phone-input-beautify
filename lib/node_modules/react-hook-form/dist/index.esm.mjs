"use client";
import i from "react";
var w = (e) => e.type === "checkbox", E = (e) => e instanceof Date, S = (e) => e == null;
const P = (e) => typeof e == "object";
var _ = (e) => !S(e) && !Array.isArray(e) && P(e) && !E(e), j = (e) => _(e) && e.target ? w(e.target) ? e.target.checked : e.target.value : e, B = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, R = (e, r) => e.has(B(r)), T = (e) => {
  const r = e.constructor && e.constructor.prototype;
  return _(r) && r.hasOwnProperty("isPrototypeOf");
}, U = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function m(e) {
  let r;
  const t = Array.isArray(e);
  if (e instanceof Date)
    r = new Date(e);
  else if (e instanceof Set)
    r = new Set(e);
  else if (!(U && (e instanceof Blob || e instanceof FileList)) && (t || _(e)))
    if (r = t ? [] : {}, !t && !T(e))
      r = e;
    else
      for (const n in e)
        e.hasOwnProperty(n) && (r[n] = m(e[n]));
  else
    return e;
  return r;
}
var x = (e) => Array.isArray(e) ? e.filter(Boolean) : [], g = (e) => e === void 0, l = (e, r, t) => {
  if (!r || !_(e))
    return t;
  const n = x(r.split(/[,[\].]+?/)).reduce((s, o) => S(s) ? s : s[o], e);
  return g(n) || n === e ? g(e[r]) ? t : e[r] : n;
}, v = (e) => typeof e == "boolean";
const A = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, h = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, D = i.createContext(null), p = () => i.useContext(D);
var L = (e, r, t, n = !0) => {
  const s = {
    defaultValues: r._defaultValues
  };
  for (const o in e)
    Object.defineProperty(s, o, {
      get: () => {
        const c = o;
        return r._proxyFormState[c] !== h.all && (r._proxyFormState[c] = !n || h.all), t && (t[c] = !0), e[c];
      }
    });
  return s;
}, W = (e) => _(e) && !Object.keys(e).length, I = (e, r, t, n) => {
  t(e);
  const { name: s, ...o } = e;
  return W(o) || Object.keys(o).length >= Object.keys(r).length || Object.keys(o).find((c) => r[c] === (!n || h.all));
}, H = (e) => Array.isArray(e) ? e : [e], C = (e, r, t) => !e || !r || e === r || H(e).some((n) => n && (t ? n === r : n.startsWith(r) || r.startsWith(n)));
function F(e) {
  const r = i.useRef(e);
  r.current = e, i.useEffect(() => {
    const t = !e.disabled && r.current.subject && r.current.subject.subscribe({
      next: r.current.next
    });
    return () => {
      t && t.unsubscribe();
    };
  }, [e.disabled]);
}
function M(e) {
  const r = p(), { control: t = r.control, disabled: n, name: s, exact: o } = e || {}, [c, f] = i.useState(t._formState), a = i.useRef(!0), d = i.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }), u = i.useRef(s);
  return u.current = s, F({
    disabled: n,
    next: (y) => a.current && C(u.current, y.name, o) && I(y, d.current, t._updateFormState) && f({
      ...t._formState,
      ...y
    }),
    subject: t._subjects.state
  }), i.useEffect(() => (a.current = !0, d.current.isValid && t._updateValid(!0), () => {
    a.current = !1;
  }), [t]), L(c, t, d.current, !1);
}
var N = (e) => typeof e == "string", $ = (e, r, t, n, s) => N(e) ? (n && r.watch.add(e), l(t, e, s)) : Array.isArray(e) ? e.map((o) => (n && r.watch.add(o), l(t, o))) : (n && (r.watchAll = !0), t);
function K(e) {
  const r = p(), { control: t = r.control, name: n, defaultValue: s, disabled: o, exact: c } = e || {}, f = i.useRef(n);
  f.current = n, F({
    disabled: o,
    subject: t._subjects.values,
    next: (u) => {
      C(f.current, u.name, c) && d(m($(f.current, t._names, u.values || t._formValues, !1, s)));
    }
  });
  const [a, d] = i.useState(t._getWatch(n, s));
  return i.useEffect(() => t._removeUnmounted()), a;
}
var q = (e) => /^\w*$/.test(e), z = (e) => x(e.replace(/["|']|\]/g, "").split(/\.|\[/)), O = (e, r, t) => {
  let n = -1;
  const s = q(r) ? [r] : z(r), o = s.length, c = o - 1;
  for (; ++n < o; ) {
    const f = s[n];
    let a = t;
    if (n !== c) {
      const d = e[f];
      a = _(d) || Array.isArray(d) ? d : isNaN(+s[n + 1]) ? {} : [];
    }
    e[f] = a, e = e[f];
  }
  return e;
};
function J(e) {
  const r = p(), { name: t, disabled: n, control: s = r.control, shouldUnregister: o } = e, c = R(s._names.array, t), f = K({
    control: s,
    name: t,
    defaultValue: l(s._formValues, t, l(s._defaultValues, t, e.defaultValue)),
    exact: !0
  }), a = M({
    control: s,
    name: t
  }), d = i.useRef(s.register(t, {
    ...e.rules,
    value: f,
    ...v(e.disabled) ? { disabled: e.disabled } : {}
  }));
  return i.useEffect(() => {
    const u = s._options.shouldUnregister || o, y = (b, k) => {
      const V = l(s._fields, b);
      V && (V._f.mount = k);
    };
    if (y(t, !0), u) {
      const b = m(l(s._options.defaultValues, t));
      O(s._defaultValues, t, b), g(l(s._formValues, t)) && O(s._formValues, t, b);
    }
    return () => {
      (c ? u && !s._state.action : u) ? s.unregister(t) : y(t, !1);
    };
  }, [t, s, c, o]), i.useEffect(() => {
    l(s._fields, t) && s._updateDisabledField({
      disabled: n,
      fields: s._fields,
      name: t,
      value: l(s._fields, t)._f.value
    });
  }, [n, t, s]), {
    field: {
      name: t,
      value: f,
      ...v(n) || a.disabled ? { disabled: a.disabled || n } : {},
      onChange: i.useCallback((u) => d.current.onChange({
        target: {
          value: j(u),
          name: t
        },
        type: A.CHANGE
      }), [t]),
      onBlur: i.useCallback(() => d.current.onBlur({
        target: {
          value: l(s._formValues, t),
          name: t
        },
        type: A.BLUR
      }), [t, s]),
      ref: (u) => {
        const y = l(s._fields, t);
        y && u && (y._f.ref = {
          focus: () => u.focus(),
          select: () => u.select(),
          setCustomValidity: (b) => u.setCustomValidity(b),
          reportValidity: () => u.reportValidity()
        });
      }
    },
    formState: a,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: !0,
        get: () => !!l(a.errors, t)
      },
      isDirty: {
        enumerable: !0,
        get: () => !!l(a.dirtyFields, t)
      },
      isTouched: {
        enumerable: !0,
        get: () => !!l(a.touchedFields, t)
      },
      error: {
        enumerable: !0,
        get: () => l(a.errors, t)
      }
    })
  };
}
export {
  l as get,
  O as set,
  J as useController,
  p as useFormContext,
  M as useFormState,
  K as useWatch
};
